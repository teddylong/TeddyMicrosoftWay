C#垃圾回收
C#的Garbage Collector(GC,垃圾回收器)往往让很多程序员产生了对于程序中使用的内存撒手不管的态度。他们会认为既然已经有GC在后台运行了，代码中就不需要多加注意了。事实上GC
可以是最好的朋友，也可以是最坏的敌人，完全取决于代码。 

★垃圾回收器的基本假定★：
1.被分配内存空间的对象最有可能被释放。在方法执行时，就需要为该方法的对象分配内存空间，搜索最近分配的对象集合有助于花费最少的代价来尽可能多地释放内存空间。
2.生命期最长的对象释放的可能性最小，经过几轮垃圾回收后，对象仍然存在，搜索它时就需要进行大量的工作，却只能释放很小的一部分空间。
3.同时被分配内存的对象通常是同时使用，将它们彼此相连有助于提高缓存性能和回收效率。

C#中的回收器是分代的垃圾回收器（Gererational Garbage Collector) 它将分配的对象分为3个类别或代。（可用GC.GetGeneration方法返回任意作为参数的对象当前所处的代）最近被
分配内存的对象被放置于第0 代，因为第0代很小，小到足以放进处理器的二级（L2)缓存，所以它能够提供对对象的快速存取。经过一轮垃圾回收后，仍然保留在第0代中的对象被移进第1 
代中，再经过一轮垃圾内存回收后，仍然保留在第1代中的对象则被移进第2代中，第2代中包含了生存期较长的对象。

在C#中值类型是在堆栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。而引用类型是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。
C#为一个对象分配内存时，托管堆可以立即返回新对象所需的内存，因为托管堆类似于简单的字节数组，有一个指向第一个可用内存空间的指针，指针像游标一样向后移动，一段段内存就分配
给了正在运行的程序的对象。在不需要太多垃圾回收的程序中，托管堆性能优于传统的堆。

当第0代中没有可以分配的有效内存时，就触发了第0代中的一轮垃圾回收，它将删除那些不再被引用的对象，并将当前正在使用的对象移至第1代。而当第0代垃圾回收后依然不能请求到充足的
内存时，就启动第1代垃圾回收。如果对各代都进行了垃圾回收后仍没有可用的内存就会引发一个 OutOfMemoryException异常。

终结器(Finalize方法)
在有些情况下，类可以提供一个终结器在对象被销毁时执行，终结器是一个名为Finalize的受保护的方法：


protected void Finalize()
{
base.Finalize();
//释放外部资源
}
垃圾回收器使用名为“终止队列”的内部结构跟踪具有 Finalize 方法的对象。每次您的应用程序创建具有 Finalize 方法的对象时，垃圾回收器都在终止队列中放置一个指向该对象的项。
托管堆中所有需要在垃圾回收器回收其内存之前调用它们的终止代码的对象都在终止队列中含有项。（实现Finalize方法或析构函数对性能可能会有负面影响，因此应避免不必要地使用它们。
用Finalize方法回收对象使用的内存需要至少两次垃圾回收。当垃圾回收器执行回收时，它只回收没有终结器的不可访问对象的内存。这时，它不能回收具有终结器的不可访问对象。它改为
将这些对象的项从终止队列中移除并将它们放置在标为准备终止的对象列表中。该列表中的项指向托管堆中准备被调用其终止代码的对象。垃圾回收器为此列表中的对象调用Finalize方法，
然后将这些项从列表中移除。后来的垃圾回收将确定终止的对象确实是垃圾，因为标为准备终止对象的列表中的项不再指向它们。在后来的垃圾回收中，实际上回收了对象的内存。概括而言
，就是将垃圾回收分为了三个阶段，第一个阶段回收没有Finalize方法或者析构函数的对象，第二个阶段调用那些析构函数或者Finalize方法，第三个阶段回收那些刚调用了析构函数或者
Finalize方法的对象。）

终结器（finalizer）是在回收过程中，由垃圾回收器调用的方法。如何含有终结器的对象到了G2中，那么就会需要非常长的时间来回收。事实上，根据应用程序运行时间的长短，对象很有
机会直到应用程序退出之前都不会被回收（特别是其中包含的重要的资源得不得释放，将会对性能产生很大的影响，比如说数据库连接得不到释放。）

 

Dispose方法
在不使用终结器时，可以考虑使用Dispose方法，你可以使用这个方法来释放所保存包括的在托管对象引用在内的任何资源。系统类中如何实现了Dispose方法，那么一般Dispose方法中都包
含了SuppressFinalize方法，这个方法会告知系统这个类已经不再需要析构了，这样可以提高释放资源的效率。所以在自定义类中的Dispose方法应该调用GC.SuppressFinalize来告知运行
时这些对象不需要析构。

System.GC类
GC类包含了可使用户与垃圾回收机制进行互操作的静态方法，包括发起新一轮垃圾回收操作的方法。确定某对象当前所在代的方法及当前分配内存空间的方法。

GC.Collect();//无参时将发起一轮全面的回收。（完全回收之前，应用程序会停止响应，因此不建议使用。）
GC.Collect(i);//(0<=i<=2)对第i代进行垃圾回收。
GetTotalMemory将返因分配于托管堆上的内存空间总量。当参数为True时，在计算之前将进行一轮全面的垃圾回收。

-----------------------------------------------------------------------------------------------------------------------------------------------

三种最常的方法如下：
 
　　1. 析构函数;(由GC调用，不确定什么时候会调用)
 
　　2. 继承IDisposable接口，实现Dispose方法;(可以手动调用。比如数据库的连接，SqlConnection.Dispose()，因为如果及时释放会影响数据库性能。这时候会用到这个，再如：
文件的打开，如果不释放会影响其它操作，如删除操作。调用Dispose后这个对象就不能再用了，就等着被GC回收。)
 
　　3. 提供Close方法。(类似Dispose但是，当调用完Close方法后，可以通过Open重新打开)
 
 ----------------------------------------------------------------------------------------------------------------------------------------------

1，C#的垃圾回收机制
 
C#的垃圾回收机制不是基于引用计数的，而是基于对象是否可到达。该机制的运作过程是：CLR 会建立一个对象图，代表堆上可达的每一个对象，如果在一次垃圾回收过程中，某个对象在该
对象图上没有root（即没有任何其他对象依赖于它），则对象是不可达对象，会被标记为垃圾，从而会被终结，从内存中清除。 微软的回收算法使用对象代，用于终结对象的辅助线程和专门
承载大对象的托管堆进行优化以提高垃圾回收机制的效率。
 
2，终结过程
 
Finalize() 的作用是保证.NET对象能在垃圾回收时清除非托管资源。如果创建了一个不使用非托管实体的类型，终结是没有用的。事实上，尽可能在设计时避免提供Finalize()以提高效率，
因为终结是需要花费时间的。当在托管堆上分配对象时，运行库自动确定该对象是否提供一个自定义的Finalize()方。如果是这样的话，该对象就被标记为可终结的，同时一个指向该对象的指
针被保存至名为终结队列的内部队列中。终结队列是一个由垃圾回收器维护的表，它指向每一个在从堆上删除之前必须被终结的对象。
 
当垃圾回收器确定需要从内存中释放一个对象时，它会检查终结队列中的每一项，并将对象从堆上复制到另一个称作终结可达表的托管结构上。此时，下一个垃圾回收时将产生另一个线程，为
每一个可达表中的对象调用Finalize()方法。因此，为了真正终结一个对象，至少要进行两次垃圾回收。
 
总而言之，尽管对象的终结能够保证对象可以清除非托管的资源，但它本质上仍然是非确定的，而且由于额外的幕后处理，速度会变得相当慢。为了尽可能快地释放非托管资源，我们引入了 
IDisposable 接口，该接口定义了一个名为 Dispose() 的方法，该方法假设当对象的用户不再使用该对象时，会这个对象引用离开作用域之前手工地调用 Dispose()。这样对象可以执行任
何必要的非托管资源的清除，而不会再有对象放在终结队列上导致的性能损失，也不必等到垃圾回收触发类的终结逻辑。
 
Finalize()只适用于类类型，而 IDisposable 接口对结构和类类型均适用。注意，如果对象支持 IDisposable 接口，那么总是要对任何直接创建的对象调用 Dispose()，因为如果类设计
者选择实现该接口，说明该类需要手动执行清理工作。注意：基类库中的许多类型实现了该接口，并提供了 Dispose() 方法的别名，如 System.IO.FileSteam类 Close()。我们可以不管别
名，只调用 Dispose() 总是正确的。
 
3，可重用 using 关键字来简化在 try/finally 块中手动调用 Dispose() 方法的编写。using 语法保证当使用支持 IDisposable接口的.NET类型的对象在退出using块时，该对象会自动
调用Dispose()方法。
 
4，可终结类型是重写了System.Object.Finalize()虚方法（在析构函数中编写清除代码）以在回收垃圾时清除非托管资源的类。而可处置对象是实现了IDisposable接口的类或结构，对象用
户将在IDisposable接口被实行后调用它。我们可以将这两种方式结合，如果对象用户调用了Dispose()，则可以通过调用GC.SuppressFinalize()通知垃圾回收器跳过终结过程；如果对象用
户忘记调用Dispose()，对象最终也将被终结并有机会释放内部资源。对象的内部非托管资源总会用其中一种方式被释放掉。

-----------------------------------------------------------------------------------------------------------------------------------------------

Finalize 和Dispose(bool disposing)和 Dispose() 的相同点:
这三者都是为了释放非托管资源服务的
Finalize 和 Dispose() 和Dispose(bool disposing)的不同点:

Finalize是CRL提供的一个机制, 它保证如果一个类实现了Finalize方法,那么当该类对象被垃圾回收时,垃圾回收器会调用Finalize方法.而该类的开发者就必须在Finalize方法中处理 非托
管资源的释放. 但是什么时候会调用Finalize由垃圾回收器决定,该类对象的使用者(客户)无法控制.从而无法及时释放掉宝贵的非托管资源.由于非托管资源是比较宝贵了,所以这样会降低性
能.
Dispose(bool disposing)不是CRL提供的一个机制, 而仅仅是一个设计模式(作为一个IDisposable接口的方法),它的目的是让供类对象的使用者(客户)在使用完类对象后,可以及时手动调用
非托管资源的释放,无需等到该类对象被垃圾回收那个时间点.这样类的开发者就只需把原先写在Finalize的释放非托管资源的代码,移植到Dispose(bool disposing)中.&nbsp; 
而在Finalize中只要简单的调用 "Dispose(false)"(为什么传递false后面解释)就可以了

这个时候我们可能比较疑惑,为什么还需要一个Dispose()方法?难道只有一个Dispose(bool disposing)或者只有一个Dispose()不可以吗?答案是:
只有一个Dispose()不可以. 为什么呢?因为如果只有一个Dispose()而没有Dispose(bool disposing)方法.那么在处理实现非托管资源释放的代码中无法判断该方法是
客户调用的还是垃圾回收器通过Finalize调用的.无法实现 判断如果是客户手动调用,那么就不希望垃圾回收器再调用Finalize()(调用GC.SupperFinalize方法).另一个可能的原因(:我们
知道如果是垃圾回收器通过Finalize调用的,那么在释放代码中我们可能还会引用其他一些托管对象,而此时这些托管对象可能已经被垃圾回收了, 这样会导致无法预知的执行结果(千万不要
在Finalize中引用其他的托管对象).
所以确实需要一个bool disposing参数, 但是如果只有一个Dispose(bool disposing),那么对于客户来说,就有一个很滑稽要求,
Dispose(false)已经被Finalize使用了,必须要求客户以Dispose(true)方式调用,但是谁又能保证客户不会以Dispose(false)方式调用呢?所以这里采用了一中设计模式:重载
把Dispose(bool disposing)实现为 protected, 而Dispose()实现为Public,那么这样就保证了客户只能调用Dispose()(内部调用Dispose(true)//说明是客户的直接调用),客户无法调
用Dispose(bool disposing). 