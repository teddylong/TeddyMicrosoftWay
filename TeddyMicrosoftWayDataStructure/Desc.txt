堆栈stack 

堆栈中存储值类型。
 
堆栈实际上是向下填充，即由高内存地址指向地内存地址填充。
 
堆栈的工作方式是先分配内存的变量后释放（先进后出原则）。
 
堆栈中的变量是从下向上释放，这样就保证了堆栈中先进后出的规则不与变量的生命周期起冲突！
 
堆栈的性能非常高，但是对于所有的变量来说还不太灵活，而且变量的生命周期必须嵌套。
 
通常我们希望使用一种方法分配内存来存储数据，并且方法退出后很长一段时间内数据仍然可以使用。此时就要用到堆（托管堆）！
 
 
 
堆（托管堆）heap
 
堆（托管堆）存储引用类型。
 
此堆非彼堆，.NET中的堆由垃圾收集器自动管理。
 
与堆栈不同，堆是从下往上分配，所以自由的空间都在已用空间的上面。（先进先出原则）
 
比如创建一个对象：
 
Customer cus;
 
cus = new Customer();
 
申明一个Customer的引用cus，在堆栈上给这个引用分配存储空间。这仅仅只是一个引用，不是实际的Customer对象！
 
cus占4个字节的空间，包含了存储Customer的引用地址。
 
接着分配堆上的内存以存储Customer对象的实例，假定Customer对象的实例是32字节，为了在堆上找到一个存储Customer对象的存储位置。
 
.NET运行库在堆中搜索第一个从未使用的，32字节的连续块存储Customer对象的实例！
 
然后把分配给Customer对象实例的地址赋给cus变量！
 
 
 
从这个例子中可以看出，建立对象引用的过程比建立值变量的过程复杂，且不能避免性能的降低！
 
实际上就是.NET运行库保存对的状态信息，在堆中添加新数据时，堆栈中的引用变量也要更新。性能上损失很多！
 
有种机制在分配变量内存的时候，不会受到堆栈的限制：把一个引用变量的值赋给一个相同类型的变量，那么这两个变量就引用同一个堆中的对象。
 
当一个应用变量出作用域时，它会从堆栈中删除。但引用对象的数据仍然保留在堆中，一直到程序结束 或者 该数据不被任何变量应用时，垃圾收集器会删除它。

-------------------------------------------------------------------------------------------------------------------------------------------------

栈（stack）是一种数据结构，栈中每个指针（当运行到那个变量时）会指向堆中的某一内存区域或说是空间。它是以先进后出为原则的。

堆（heap）就直接是内存区域了，它是为了栈的引用而开发内存的。通常内置变量就是值类型是被保存在栈中的。其他由.NET框架(Framework)提供的,或者是我们自己定义的对象即引用类
型，一般被创建在堆中并将由栈中变量引用。

那么它们运行时的释放是怎样呢？首先刚才说了，栈中会有指针指向堆，其实那叫栈帧（当一个函数被调用时，栈就去堆中借一块内存给它），当函数返回时，栈帧被释放，栈帧中的对象超
出作用域而被销毁。这就是一个变量的生命周期了，一只工蜂的生命就是他完成了采蜜工作。而堆中的对象是在没有栈帧指向它的时候，也就是工蜂采完蜜了，蜂王产下卵之后就结束生命了。
之后堆中的对象就通过CLR垃圾回收系统销毁。

当一个方法被调用，调用栈会分配一块空间成为栈页，用来保存被调用方法的下一条指令的返回地址。也就是说它会将调用方法之后会产生什么的返回地址发给被调用方法的参数以及被调用
方法的所有局部变量。所以“展开调用栈”就是指找到被调用方法的返回地址并强制方法返回，在调用方法的方法中寻找catch语句或其他处理异常的语句来处理异常。在找到异常处理代码之前
，栈要“展开”很多被调用的方法。如果最终栈展开到main方法儿还是没找到异常处理代码，默认的异常处理就会被调用，整个程序被终结，栈中的变量和栈帧被销毁，程序终止。

其实如果程序找到了异常处理的代码就会从那段代码开始继续，而不是从抛出异常的地方，或是从调用了抛出异常方法的方法（除非这个方法包含异常处理代码），一定拿栈页被展开，他就
被释放。

--------------------------------------------------------------------------------------------------------------------------------------------------

总结：
堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就
走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自
由度小。
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由
度大。

---------------------------------------------------------------------------------------------------------------------------------------------------


二叉树的深度优先遍历、广度优先遍历和非递归遍历 
二叉树的遍历：

D：访问根结点，L：遍历根结点的左子树，R：遍历根结点的右子树。

给定一棵二叉树的前序遍历序列和中序遍历序列可以惟一确定一棵二叉树。

二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列。

深度优先遍历二叉树。

1. 中序遍历（LDR）的递归算法：

若二叉树为空，则算法结束；否则：

    中序遍历根结点的左子树；

    访问根结点；

    中序遍历根结点的右子树。

2. 前序遍历（DLR）的递归算法：

若二叉树为空，则算法结束，否则：

    访问根结点；

    前序遍历根结点的左子树；

    前序遍历根结点的右子树。

3. 后序遍历（LRD）的递归算法：

若二叉树为空，则算法结束，否则：

    后序遍历根结点的左子树；

    后序遍历根结点的右子树；

    访问根结点。

 

广度优先遍历二叉树。

广度优先周游二叉树(层序遍历)是用队列来实现的，从二叉树的第一层（根结点）开始，自上至下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。

按照从根结点至叶结点、从左子树至右子树的次序访问二叉树的结点。算法：

    1初始化一个队列，并把根结点入列队；

    2当队列为非空时，循环执行步骤3到步骤5，否则执行6；

    3出队列取得一个结点，访问该结点；

    4若该结点的左子树为非空，则将该结点的左子树入队列；

    5若该结点的右子树为非空，则将该结点的右子树入队列；

    6结束。

 

非递归深度优先遍历二叉树。

栈是实现递归的最常用的结构，利用一个栈来记下尚待遍历的结点或子树，以备以后访问，可以将递归的深度优先遍历改为非递归的算法。

1. 非递归前序遍历：遇到一个结点，就访问该结点，并把此结点推入栈中，然后下降去遍历它的左子树。遍历完它的左子树后，从栈顶托出这个结点，并按照它的右链接指示的地址再去遍
历该结点的右子树结构。

2. 非递归中序遍历：遇到一个结点，就把它推入栈中，并去遍历它的左子树。遍历完左子树后，从栈顶托出这个结点并访问之，然后按照它的右链接指示的地址再去遍历该结点的右子树。

3. 非递归后序遍历：遇到一个结点，把它推入栈中，遍历它的左子树。遍历结束后，还不能马上访问处于栈顶的该结点，而是要再按照它的右链接结构指示的地址去遍历该结点的右子树。
遍历遍右子树后才能从栈顶托出该结点并访问之。另外，需要给栈中的每个元素加上一个特征位，以便当从栈顶托出一个结点时区别是从栈顶元素左边回来的(则要继续遍历右子树)，还是
从右边回来的(该结点的左、右子树均已周游)。特征为Left表示已进入该结点的左子树，将从左边回来；特征为Right表示已进入该结点的右子树，将从右边回来。

4. 简洁的非递归前序遍历：遇到一个结点，就访问该结点，并把此结点的非空右结点推入栈中，然后下降去遍历它的左子树。遍历完左子树后，从栈顶托出一个结点，并按照它的右链接
指示的地址再去遍历该结点的右子树结构。

----------------------------------------------------------------------

图的深度优先搜索法是树的先根遍历的推广，它的基本思想是：从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻
且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发
按同样的方法向前遍历，直到图中所有顶点都被访问。
图的广度优先搜索是树的按层次遍历的推广，它的基本思想是：首先访问初始点vi，并将其标记为已访问过，接着访问vi的所有未被访问过的邻接点vi1,vi2, …, vi t，并均标记已
访问过，然后再按照vi1,vi2, …, vi t的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点vi有路径相通的顶点都被访问
过为止。



